%%Mandelbrot fractal


function it = fractal(c)
    maxIter = 100; %max number of iterations
    z = 0; %take z=0 at the start

    for it = 1:maxIter
        z = z^2 + c; %recurrence fucntion
        if abs(z) > 2 %check if it has diverged
            return %if it diverges, we exit
        end
    end
    it = maxIter; %if we finish the for loop that means we never diverged
end

function fn = indicator_fn_at_x(x)
    %we return +1 if we escape
    %we return -1 if we stay bounded
    %@(y) makes it an anonymous function
    fn = @(y) (fractal(x + 1i * y)<100) * 2 -1; %tests if we are in or outside of the set
    %this works since if we don't escape, we return 100 from fractal(c)
    %which will make fn -1
end

function m = bisection(fn_f, s, e)
    maxIter = 1000; %max number of steps to do
    tolerance = 1e-7; %can be changed, set to 1e-6 for now

    for k = 1:maxIter
        m = (s + e)/2; %midpoint
        if fn_f(m) == fn_f(s)
            s = m; %if we have the same sign we move lower bound
        else
            e = m; %else we move the upper bound
        end
        if abs(e-s)<tolerance
            m = (s + e)/2;
            return
        end
    end
end

numPoints = 1000;
xValues = linspace(-2, 1, numPoints);
yValues = NaN(size(xValues));

maxY = 1;   % how far we search vertically
dy   = 0.01; % step size

for i = 1:numPoints
    x = xValues(i);
    fn = indicator_fn_at_x(x);

    % --- search upward (positive Im axis) ---
    y = 0;
    while y < maxY
        if fn(y) ~= fn(y+dy)   % sign change detected
            yValues(i) = bisection(fn, y, y+dy);
            break
        end
        y = y + dy;
    end
end

plot(xValues, yValues, 'b.', 'MarkerSize', 4)
grid on
xlabel('Re(c)')
ylabel('Im(c) of boundary')
title('Approximate Mandelbrot Boundaries')